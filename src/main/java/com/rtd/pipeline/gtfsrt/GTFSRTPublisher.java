package com.rtd.pipeline.gtfsrt;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.Executors;

/**
 * HTTP server that publishes GTFS-RT protobuf files at RTD-compatible endpoints.
 * Serves the files generated by GTFSRTFeedGenerator with proper headers and caching.
 */
public class GTFSRTPublisher {
    
    private static final Logger LOG = LoggerFactory.getLogger(GTFSRTPublisher.class);
    
    private final HttpServer httpServer;
    private final String gtfsRtDirectory;
    private final ObjectMapper objectMapper;
    
    // Server configuration
    private static final int DEFAULT_PORT = 8084;
    private static final String GTFS_RT_CONTENT_TYPE = "application/x-protobuf";
    private static final String JSON_CONTENT_TYPE = "application/json";
    private static final int CACHE_MAX_AGE_SECONDS = 30; // Cache for 30 seconds
    
    // File paths
    private static final String VEHICLE_POSITIONS_FILE = "VehiclePosition.pb";
    private static final String TRIP_UPDATES_FILE = "TripUpdate.pb";
    private static final String ALERTS_FILE = "Alerts.pb";
    
    public GTFSRTPublisher(String gtfsRtDirectory, int port) throws IOException {
        this.gtfsRtDirectory = gtfsRtDirectory;
        this.objectMapper = new ObjectMapper();
        this.httpServer = HttpServer.create(new InetSocketAddress(port), 0);
        
        setupRoutes();
        this.httpServer.setExecutor(Executors.newFixedThreadPool(10));
        
        LOG.info("GTFS-RT Publisher initialized on port {} serving from directory: {}", port, gtfsRtDirectory);
    }
    
    public GTFSRTPublisher(String gtfsRtDirectory) throws IOException {
        this(gtfsRtDirectory, DEFAULT_PORT);
    }
    
    private void setupRoutes() {
        // RTD-compatible endpoints (primary)
        httpServer.createContext("/files/gtfs-rt/VehiclePosition.pb", new ProtobufFileHandler(VEHICLE_POSITIONS_FILE));
        httpServer.createContext("/files/gtfs-rt/TripUpdate.pb", new ProtobufFileHandler(TRIP_UPDATES_FILE));
        httpServer.createContext("/files/gtfs-rt/Alerts.pb", new ProtobufFileHandler(ALERTS_FILE));
        
        // Alternative API endpoints (secondary)
        httpServer.createContext("/api/download/gtfs-rt/VehiclePosition.pb", new ProtobufFileHandler(VEHICLE_POSITIONS_FILE));
        httpServer.createContext("/api/download/gtfs-rt/TripUpdate.pb", new ProtobufFileHandler(TRIP_UPDATES_FILE));
        httpServer.createContext("/api/download/gtfs-rt/Alerts.pb", new ProtobufFileHandler(ALERTS_FILE));
        
        // Status and health endpoints
        httpServer.createContext("/gtfs-rt/status", new StatusHandler());
        httpServer.createContext("/gtfs-rt/health", new HealthHandler());
        
        // Root endpoint with feed information
        httpServer.createContext("/gtfs-rt", new InfoHandler());
        httpServer.createContext("/", new RootHandler());
    }
    
    public void start() {
        httpServer.start();
        LOG.info("âœ… GTFS-RT Publisher started");
        LOG.info("ðŸ“¡ Vehicle Positions: http://localhost:{}/files/gtfs-rt/VehiclePosition.pb", getPort());
        LOG.info("ðŸ“¡ Trip Updates: http://localhost:{}/files/gtfs-rt/TripUpdate.pb", getPort());
        LOG.info("ðŸ“¡ Alerts: http://localhost:{}/files/gtfs-rt/Alerts.pb", getPort());
        LOG.info("ðŸ“Š Status: http://localhost:{}/gtfs-rt/status", getPort());
    }
    
    public void stop() {
        httpServer.stop(5);
        LOG.info("GTFS-RT Publisher stopped");
    }
    
    public int getPort() {
        return httpServer.getAddress().getPort();
    }
    
    /**
     * Handler for serving protobuf files
     */
    private class ProtobufFileHandler implements HttpHandler {
        private final String fileName;
        
        public ProtobufFileHandler(String fileName) {
            this.fileName = fileName;
        }
        
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String method = exchange.getRequestMethod();
            
            if (!"GET".equals(method)) {
                sendErrorResponse(exchange, 405, "Method not allowed");
                return;
            }
            
            try {
                Path filePath = Paths.get(gtfsRtDirectory, fileName);
                
                if (!Files.exists(filePath)) {
                    LOG.warn("GTFS-RT file not found: {}", filePath);
                    sendErrorResponse(exchange, 404, "GTFS-RT feed not available");
                    return;
                }
                
                // Check file age
                long lastModified = Files.getLastModifiedTime(filePath).toMillis();
                long ageSeconds = (System.currentTimeMillis() - lastModified) / 1000;
                
                if (ageSeconds > 300) { // 5 minutes
                    LOG.warn("GTFS-RT file is stale: {} (age: {}s)", fileName, ageSeconds);
                }
                
                // Read file content
                byte[] content = Files.readAllBytes(filePath);
                
                // Set response headers
                exchange.getResponseHeaders().set("Content-Type", GTFS_RT_CONTENT_TYPE);
                exchange.getResponseHeaders().set("Cache-Control", "max-age=" + CACHE_MAX_AGE_SECONDS);
                exchange.getResponseHeaders().set("Last-Modified", 
                    DateTimeFormatter.RFC_1123_DATE_TIME.format(
                        Instant.ofEpochMilli(lastModified).atZone(ZoneId.of("GMT"))));
                exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
                exchange.getResponseHeaders().set("Access-Control-Allow-Methods", "GET");
                
                // Send response
                exchange.sendResponseHeaders(200, content.length);
                try (OutputStream os = exchange.getResponseBody()) {
                    os.write(content);
                }
                
                LOG.debug("Served GTFS-RT file: {} ({} bytes, age: {}s)", fileName, content.length, ageSeconds);
                
            } catch (Exception e) {
                LOG.error("Error serving GTFS-RT file {}: {}", fileName, e.getMessage(), e);
                sendErrorResponse(exchange, 500, "Internal server error");
            }
        }
    }
    
    /**
     * Handler for status endpoint
     */
    private class StatusHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equals(exchange.getRequestMethod())) {
                sendErrorResponse(exchange, 405, "Method not allowed");
                return;
            }
            
            try {
                ObjectNode status = objectMapper.createObjectNode();
                status.put("service", "gtfs-rt-publisher");
                status.put("status", "running");
                status.put("timestamp", Instant.now().toString());
                status.put("directory", gtfsRtDirectory);
                
                // Check file status
                ObjectNode files = objectMapper.createObjectNode();
                files.set("vehiclePositions", getFileStatus(VEHICLE_POSITIONS_FILE));
                files.set("tripUpdates", getFileStatus(TRIP_UPDATES_FILE));
                files.set("alerts", getFileStatus(ALERTS_FILE));
                status.set("files", files);
                
                sendJsonResponse(exchange, status);
                
            } catch (Exception e) {
                LOG.error("Error generating status: {}", e.getMessage(), e);
                sendErrorResponse(exchange, 500, "Internal server error");
            }
        }
        
        private ObjectNode getFileStatus(String fileName) {
            ObjectNode fileStatus = objectMapper.createObjectNode();
            Path filePath = Paths.get(gtfsRtDirectory, fileName);
            
            try {
                if (Files.exists(filePath)) {
                    long size = Files.size(filePath);
                    long lastModified = Files.getLastModifiedTime(filePath).toMillis();
                    long ageSeconds = (System.currentTimeMillis() - lastModified) / 1000;
                    
                    fileStatus.put("exists", true);
                    fileStatus.put("size", size);
                    fileStatus.put("lastModified", Instant.ofEpochMilli(lastModified).toString());
                    fileStatus.put("ageSeconds", ageSeconds);
                    fileStatus.put("status", ageSeconds < 300 ? "current" : "stale");
                } else {
                    fileStatus.put("exists", false);
                    fileStatus.put("status", "missing");
                }
            } catch (Exception e) {
                fileStatus.put("exists", false);
                fileStatus.put("status", "error");
                fileStatus.put("error", e.getMessage());
            }
            
            return fileStatus;
        }
    }
    
    /**
     * Handler for health check endpoint
     */
    private class HealthHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equals(exchange.getRequestMethod())) {
                sendErrorResponse(exchange, 405, "Method not allowed");
                return;
            }
            
            ObjectNode health = objectMapper.createObjectNode();
            health.put("status", "healthy");
            health.put("service", "gtfs-rt-publisher");
            health.put("timestamp", Instant.now().toString());
            
            // Quick health check - at least one file should exist and be recent
            boolean healthy = false;
            String[] files = {VEHICLE_POSITIONS_FILE, TRIP_UPDATES_FILE};
            
            for (String fileName : files) {
                Path filePath = Paths.get(gtfsRtDirectory, fileName);
                if (Files.exists(filePath)) {
                    try {
                        long ageSeconds = (System.currentTimeMillis() - Files.getLastModifiedTime(filePath).toMillis()) / 1000;
                        if (ageSeconds < 600) { // Within 10 minutes
                            healthy = true;
                            break;
                        }
                    } catch (Exception e) {
                        // Continue checking other files
                    }
                }
            }
            
            if (!healthy) {
                health.put("status", "unhealthy");
                health.put("error", "No recent GTFS-RT feeds available");
                sendJsonResponse(exchange, health, 503);
            } else {
                sendJsonResponse(exchange, health);
            }
        }
    }
    
    /**
     * Handler for info endpoint
     */
    private class InfoHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equals(exchange.getRequestMethod())) {
                sendErrorResponse(exchange, 405, "Method not allowed");
                return;
            }
            
            ObjectNode info = objectMapper.createObjectNode();
            info.put("service", "RTD GTFS-RT Publisher");
            info.put("description", "Provides real-time transit data in GTFS-RT format");
            info.put("version", "1.0");
            info.put("timestamp", Instant.now().toString());
            
            ObjectNode endpoints = objectMapper.createObjectNode();
            endpoints.put("vehiclePositions", "/files/gtfs-rt/VehiclePosition.pb");
            endpoints.put("tripUpdates", "/files/gtfs-rt/TripUpdate.pb");
            endpoints.put("alerts", "/files/gtfs-rt/Alerts.pb");
            endpoints.put("status", "/gtfs-rt/status");
            endpoints.put("health", "/gtfs-rt/health");
            info.set("endpoints", endpoints);
            
            sendJsonResponse(exchange, info);
        }
    }
    
    /**
     * Handler for root endpoint
     */
    private class RootHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String response = "RTD GTFS-RT Publisher\n" +
                             "Available endpoints:\n" +
                             "  /files/gtfs-rt/VehiclePosition.pb\n" +
                             "  /files/gtfs-rt/TripUpdate.pb\n" +
                             "  /files/gtfs-rt/Alerts.pb\n" +
                             "  /gtfs-rt/status\n" +
                             "  /gtfs-rt/health\n";
            
            exchange.getResponseHeaders().set("Content-Type", "text/plain");
            exchange.sendResponseHeaders(200, response.length());
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(response.getBytes());
            }
        }
    }
    
    private void sendJsonResponse(HttpExchange exchange, Object data) throws IOException {
        sendJsonResponse(exchange, data, 200);
    }
    
    private void sendJsonResponse(HttpExchange exchange, Object data, int statusCode) throws IOException {
        String json = objectMapper.writeValueAsString(data);
        byte[] bytes = json.getBytes();
        
        exchange.getResponseHeaders().set("Content-Type", JSON_CONTENT_TYPE);
        exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
        exchange.sendResponseHeaders(statusCode, bytes.length);
        
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }
    
    private void sendErrorResponse(HttpExchange exchange, int statusCode, String message) throws IOException {
        ObjectNode error = objectMapper.createObjectNode();
        error.put("error", message);
        error.put("status", statusCode);
        error.put("timestamp", Instant.now().toString());
        
        sendJsonResponse(exchange, error, statusCode);
    }
    
    public static void main(String[] args) {
        try {
            String gtfsRtDirectory = args.length > 0 ? args[0] : "data/gtfs-rt";
            int port = args.length > 1 ? Integer.parseInt(args[1]) : DEFAULT_PORT;
            
            GTFSRTPublisher publisher = new GTFSRTPublisher(gtfsRtDirectory, port);
            publisher.start();
            
            // Add shutdown hook
            Runtime.getRuntime().addShutdownHook(new Thread(publisher::stop));
            
            LOG.info("GTFS-RT Publisher is running. Press Ctrl+C to stop.");
            
            // Keep the main thread alive
            Thread.currentThread().join();
            
        } catch (Exception e) {
            LOG.error("Failed to start GTFS-RT Publisher: {}", e.getMessage(), e);
            System.exit(1);
        }
    }
}